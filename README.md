# GQL + NEO4J = ❤️
## 1.0.0 The project 💾

The New Beginnings API is a basic crud application using Neo4J, GraphQL, Apollo Server, and Node.js 🔥

A super powerful graph database and a server with lots of functionality defined in 20 lines of code and 20 lines of schemas. No baroque tooling chains, no crazy boilerplate, no endless tickets back and forth between the DBAs and the developers. This stuff is fast*! 🚀

*Seriously, a working version of the server took ~10 minutes, and this is an unfamiliar stack to me! I then proceeded to spend two hours trying to dockerise it.
## 2.0.0 Running the Service 🏃‍♂️

### 2.1.0 Prerequisites

#### 2.1.1 Docker
You can use [Docker Desktop](https://www.docker.com/products/docker-desktop/) my pick for running docker locally. But any way you want to run containers is just fine.

As mentioned above I have dockerised* the service, so you can start with just `$ docker-compose up --build`

**the docker image is set to dev mode rather than production, so you can play with it more easily*
#### 2.1.2 Node.js and Neo4J
You have options for how you want to run the project locally.
To run it locally you will need to install  [Node.js](https://nodejs.org/en/download/) this project is using the current LTS at time of writing 16.14.2.

For the sake of consistency I also would recommend yarn. If you don't have it installed you can add it most easily using npm. `$ npm i -g yarn`

You have options for how you want to run your Database.
If you want to run it locally you can start the Neo4J docker image and develop against that.

Alternatively you can install [Neo4J](https://neo4j.com/download-neo4j-now/) locally and play with the data in the Neo4J desktop app. 

Or you could set up a free account on [Neo4J AuraDB](https://neo4j.com/cloud/get-aura/) and replace the driver line in index.js with 
```js
const driver = neo4j.driver(
	process.env.NEO4J_URI,
	neo4j.auth.basic(process.env.NEO4J_USER,
	process.env.NEO4J_PASSWORD)
);
```
And then add a `.env` file with the values aura gives you on setup:
```
NEO4J_USER=neo4j
NEO4J_PASSWORD=myAuraPassword
NEO4J_URI=neo4j+s://my-aura.database
```

Once you have a local setup of Neo4J that you are happy with you can run the server
Start in production mode with `$ yarn start`

 in dev mode using `$ yarn dev` . This will start the driver in debug mode, meaning the driver will print out the cypher queries that are being generated by the service, to use in testing or to to experiment. Dev is also using nodemon to reset the server when the code changes.

## 3.0.0 API 📞

The API is currently hard coded to allow graphql experimentation.  The full definitions can be found using [the apollo sandbox explorer](https://studio.apollographql.com/sandbox/explorer). Just fire up the image, point the explorer to `localhost:4000` and it does the rest. 🆒

### 3.1.0 Your first request
First things, first, let's add someone to the database.
If we add the following operation the explorer
```js
mutation CreateCustomers($input: [CustomerCreateInput!]!) {
	createCustomers(input: $input) {
	customers {
		firstName
		middleNames
		lastName
		dateOfBirth
		phoneNumber
		uniqueID
		Addresses {
			line1
			postalCode
			town
			county
			isCurrent
			isPrimary
			}
		}
	}
}
```
And then run the mutation with these variables
```js
{
	"input": [{
		"firstName":  "Alexander",
		"middleNames":  "Boris de Pfeffel",
		"lastName":  "Johnson",
		"dateOfBirth":  "19/6/1964",
		"phoneNumber":  "07869584737",
		"uniqueID":  "PR1M13ST3R",
		"Addresses":  {
		"create": [{ "node":  {
				"line1":  "10 downing street",
				"postalCode":  "SW1A 2AA",
				"town":  "Westminster",
				"county":  "London",
				"isCurrent":  true,
				"isPrimary":  true
			}
			},{ "node":  {
				"line1":  "80 Lark Lane",
				"line2":  "Flat 2",
				"postalCode":  "UX10BR",
				"town":  "Uxbridge",
				"county":  "Berkshire",
				"isCurrent":  true,
				"isPrimary":  false
				}
			}]
		}
	}]
}
```
We will have added our first entry to the database. Immediately demonstrating the power of the graph. People move house, people, such as MPs, have second homes. The last 5 years of address history is a requirement for employers, banks, credit companies, and many more. And here we have been able to capture that information with a single mutation.

In the graph we can express a relationship with between an address and an individual. In a healthcare context you could query for all people in the same house, or postcode to see who might have been affected by a transmissible disease.

#### 3.1.1 Our mutation
To give us something to test I have added a mutation to sign up a new user with just one address.

To try our mutation, we first add the following query to the explorer
```js
mutation  CreateCustomers($firstName:  String, $middleNames:  String, $lastName:  String, $dateOfBirth:  String, $phoneNumber:  String, $line1:  String, $line2:  String, $line3:  String, $postalCode:  String, $town:  String, $country:  String, $county:  String)  {

signUp(firstName:  $firstName, middleNames:  $middleNames, lastName:  $lastName, dateOfBirth:  $dateOfBirth, phoneNumber:  $phoneNumber, line1:  $line1, line2:  $line2, line3:  $line3, postalCode:  $postalCode, town:  $town, country:  $country, county:  $county)

}
```
And add the following JSON to the variables 
```json
{
	"firstName":  "abe",
	"middleNames":  "cee",
	"lastName":  "de",
	"dateOfBirth":  "1/1/1999",
	"phoneNumber":  "07484575266",
	"line1":  "cool st",
	"line2":  "coolville towers",
	"line3":  "flat 9",
	"postalCode":  "w80aa",
	"town":  "kensignton",
	"country":  "uk",
	"county":  "london"
}
```
This will allow you to add a customer to our db taking advantage of the custom ID api

### 3.2.0 Other thoughts on API design
In a future version of this API I would update addresses to take into account the move in and move out dates, rather than just a boolean for "is this where you live right now".  

I would also consider adding the option to capture more health-related data, height and weight for example, and to begin to link customers with related datapoints on the graph.

I would also look at adding familial relationships, so we have a graph of people. This can be related to other data such as healthcare outcomes, who is their primary physician, or even individual procedures, allergies, everything. 

With enough data you could ask the graph if people with a pollen allergy are more likely to be overweight if their GP is over 50. One Cypher query can tell you all of that! You don't need a data scientist to go through it all for you, prepare and clean the data, write some spaghetti like python to start to pull it all together and rack up a big bill on a TPU.

This is, of course, all possible to change easily at a later date thanks to the power of the graph. 📈

## 4.0.0 Testing 🧪
### 4.1.0 Linting

I am using Eslint with Airbnb. I am in two minds on Airbnb, but that's a whole essay in itself. I have used it here for convenience with just one rule tweak, because double quotes are superior. 

I have also included the graphql plugin, so we can check for common mistakes in our schemas before we run them.

Run the linting with `$ yarn lint`
### Testing
The API mock code was tested with Jest you can run the tests with `$ yarn test`

I had intended to test the custom mutation using *easygraphql-tester* but ran out of time.

## 5.0.0  Workflow 👩‍💻
```mermaid
	graph  TD

	A[API User]  -->|GQL|  B[Cloud Ingress]

	B  -->  C[Apollo Server]

	C  -->|Cypher|  D(Neo4J)

	D  -->|Cypher Queries|  D
```

## 6.0.0 Todos 🔜
* Validation
	* Needs API validation, and security review before it can be made public safely.
* Dockerisation
	* Needs proper config, monitoring, error handling, and other production critical features.
* API Design
	* Comprehensive notes on API design in section 3.2.0,  Other thoughts on API design
* Testing
	* Finish writing tests for custom mutations 